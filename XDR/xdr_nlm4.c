/*
 * Please do not edit this file.
 * It was generated using rpcgen.
 */

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#ifdef _SOLARIS
#include "solaris_port.h"
#endif

#ifdef _USE_GSSRPC
#include <gssrpc/types.h>
#include <gssrpc/rpc.h>
#else
#include <rpc/types.h>
#include <rpc/rpc.h>
#endif

#include "nlm4.h"

#ifdef _USE_GSSRPC
/* These prototypes are missing in gssrpc/xdr.h */
bool_t xdr_longlong_t(XDR * __xdrs, quad_t * __llp);
bool_t xdr_u_longlong_t(XDR * __xdrs, u_quad_t * __ullp);
#endif

bool_t xdr_nlm4_stats(XDR * xdrs, nlm4_stats * objp)
{
  register int32_t *buf;

  if(!xdr_enum(xdrs, (enum_t *) objp))
    return FALSE;
  return TRUE;
}

bool_t xdr_nlm4_stat(XDR * xdrs, nlm4_stat * objp)
{
  register int32_t *buf;

  if(!xdr_nlm4_stats(xdrs, &objp->stat))
    return FALSE;
  return TRUE;
}

bool_t xdr_nlm4_res(XDR * xdrs, nlm4_res * objp)
{
  register int32_t *buf;

  if(!xdr_netobj(xdrs, &objp->cookie))
    return FALSE;
  if(!xdr_nlm4_stat(xdrs, &objp->stat))
    return FALSE;
  return TRUE;
}

bool_t xdr_nlm4_holder(XDR * xdrs, nlm4_holder * objp)
{
  register int32_t *buf;

  if(!xdr_bool(xdrs, &objp->exclusive))
    return FALSE;
  if(!xdr_int32_t(xdrs, &objp->svid))
    return FALSE;
  if(!xdr_netobj(xdrs, &objp->oh))
    return FALSE;
  if(!xdr_uint64_t(xdrs, &objp->l_offset))
    return FALSE;
  if(!xdr_uint64_t(xdrs, &objp->l_len))
    return FALSE;
  return TRUE;
}

bool_t xdr_nlm4_testrply(XDR * xdrs, nlm4_testrply * objp)
{
  register int32_t *buf;

  if(!xdr_nlm4_stats(xdrs, &objp->stat))
    return FALSE;
  switch (objp->stat)
    {
    case NLM4_DENIED:
      if(!xdr_nlm4_holder(xdrs, &objp->nlm4_testrply_u.holder))
        return FALSE;
      break;
    default:
      break;
    }
  return TRUE;
}

bool_t xdr_nlm4_testres(XDR * xdrs, nlm4_testres * objp)
{
  register int32_t *buf;

  if(!xdr_netobj(xdrs, &objp->cookie))
    return FALSE;
  if(!xdr_nlm4_testrply(xdrs, &objp->test_stat))
    return FALSE;
  return TRUE;
}

bool_t xdr_nlm4_lock(XDR * xdrs, nlm4_lock * objp)
{
  register int32_t *buf;

  if(!xdr_string(xdrs, &objp->caller_name, LM_MAXSTRLEN))
    return FALSE;
  if(!xdr_netobj(xdrs, &objp->fh))
    return FALSE;
  if(!xdr_netobj(xdrs, &objp->oh))
    return FALSE;
  if(!xdr_int32_t(xdrs, &objp->svid))
    return FALSE;
  if(!xdr_uint64_t(xdrs, &objp->l_offset))
    return FALSE;
  if(!xdr_uint64_t(xdrs, &objp->l_len))
    return FALSE;
  return TRUE;
}

bool_t xdr_nlm4_lockargs(XDR * xdrs, nlm4_lockargs * objp)
{
  register int32_t *buf;

  if(!xdr_netobj(xdrs, &objp->cookie))
    return FALSE;
  if(!xdr_bool(xdrs, &objp->block))
    return FALSE;
  if(!xdr_bool(xdrs, &objp->exclusive))
    return FALSE;
  if(!xdr_nlm4_lock(xdrs, &objp->alock))
    return FALSE;
  if(!xdr_bool(xdrs, &objp->reclaim))
    return FALSE;
  if(!xdr_int32_t(xdrs, &objp->state))
    return FALSE;
  return TRUE;
}

bool_t xdr_nlm4_cancargs(XDR * xdrs, nlm4_cancargs * objp)
{
  register int32_t *buf;

  if(!xdr_netobj(xdrs, &objp->cookie))
    return FALSE;
  if(!xdr_bool(xdrs, &objp->block))
    return FALSE;
  if(!xdr_bool(xdrs, &objp->exclusive))
    return FALSE;
  if(!xdr_nlm4_lock(xdrs, &objp->alock))
    return FALSE;
  return TRUE;
}

bool_t xdr_nlm4_testargs(XDR * xdrs, nlm4_testargs * objp)
{
  register int32_t *buf;

  if(!xdr_netobj(xdrs, &objp->cookie))
    return FALSE;
  if(!xdr_bool(xdrs, &objp->exclusive))
    return FALSE;
  if(!xdr_nlm4_lock(xdrs, &objp->alock))
    return FALSE;
  return TRUE;
}

bool_t xdr_nlm4_unlockargs(XDR * xdrs, nlm4_unlockargs * objp)
{
  register int32_t *buf;

  if(!xdr_netobj(xdrs, &objp->cookie))
    return FALSE;
  if(!xdr_nlm4_lock(xdrs, &objp->alock))
    return FALSE;
  return TRUE;
}

bool_t xdr_fsh4_mode(XDR * xdrs, fsh4_mode * objp)
{
  register int32_t *buf;

  if(!xdr_enum(xdrs, (enum_t *) objp))
    return FALSE;
  return TRUE;
}

bool_t xdr_fsh4_access(XDR * xdrs, fsh4_access * objp)
{
  register int32_t *buf;

  if(!xdr_enum(xdrs, (enum_t *) objp))
    return FALSE;
  return TRUE;
}

bool_t xdr_nlm4_share(XDR * xdrs, nlm4_share * objp)
{
  register int32_t *buf;

  if(!xdr_string(xdrs, &objp->caller_name, LM_MAXSTRLEN))
    return FALSE;
  if(!xdr_netobj(xdrs, &objp->fh))
    return FALSE;
  if(!xdr_netobj(xdrs, &objp->oh))
    return FALSE;
  if(!xdr_fsh4_mode(xdrs, &objp->mode))
    return FALSE;
  if(!xdr_fsh4_access(xdrs, &objp->access))
    return FALSE;
  return TRUE;
}

bool_t xdr_nlm4_shareargs(XDR * xdrs, nlm4_shareargs * objp)
{
  register int32_t *buf;

  if(!xdr_netobj(xdrs, &objp->cookie))
    return FALSE;
  if(!xdr_nlm4_share(xdrs, &objp->share))
    return FALSE;
  if(!xdr_bool(xdrs, &objp->reclaim))
    return FALSE;
  return TRUE;
}

bool_t xdr_nlm4_shareres(XDR * xdrs, nlm4_shareres * objp)
{
  register int32_t *buf;

  if(!xdr_netobj(xdrs, &objp->cookie))
    return FALSE;
  if(!xdr_nlm4_stats(xdrs, &objp->stat))
    return FALSE;
  if(!xdr_int32_t(xdrs, &objp->sequence))
    return FALSE;
  return TRUE;
}

bool_t xdr_nlm4_notify(XDR * xdrs, nlm4_notify * objp)
{
  register int32_t *buf;

  if(!xdr_string(xdrs, &objp->name, LM_MAXNAMELEN))
    return FALSE;
  if(!xdr_int64_t(xdrs, &objp->state))
    return FALSE;
  return TRUE;
}

bool_t xdr_nlm4_sm_notifyargs(XDR * xdrs, nlm4_sm_notifyargs * objp)
{
  register int32_t *buf;

  int i;
  if(!xdr_string(xdrs, &objp->name, SM_MAXSTRLEN))
    return FALSE;
  if(!xdr_int32_t(xdrs, &objp->state))
    return FALSE;
  if(!xdr_opaque(xdrs, objp->priv, SM_PRIV_SZ))
    return FALSE;
  return TRUE;
}
